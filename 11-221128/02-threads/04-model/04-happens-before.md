# Модель параллельных вычислений
Мотивация: есть оптимизации компилятора/процесора и кэши.
Хотим решить, по каким правилам играть.

Бывают даже слабые модели памяти, когда нельзя считать, что "потоки выполняются по очереди": https://habr.com/ru/company/JetBrains-education/blog/523298/

Решение: заводим между событиями отношение happens-before (произошло-до).
Это свойство конкретного выполнения программы(!), а не программы целиком.
Если между А и Б есть отношение, то всё ок, если нет — они произошли "одновременно" независимо от того, что показывают часы на стене (wall clock time).

Базово happens-before возникает:

1. Внутри потока: если `A; B`, то A happened-before B. Плюс ещё некоторые "sequenced-before": https://en.cppreference.com/w/cpp/language/eval_order
2. Между потоками: "отпустили мьютекс M" happens-before "взяли мьютекс M".
3. У atomic'ов: "записали в A" не совсем happens-before "прочитали из A" (есть тонкости с "код должен зависеть от прочитанного значения", но этим почти никто не пользуется).

# Пример хорошего happens-before
```c++
// Thread 1
started = true;
m.lock();
finished = true;
m.unlock();

// Thread 2
m.lock();
//std::cout << started;
if (finished) {
    assert(started);    // Верно
}
m.unlock();
```

Здесь при любом выполнении между записью `finished = true` и чтением `finished`
всегда есть happens-before либо в одну сторону, либо в другую.

Аналогично с записью/чтением `started`.
И мы даже можем делать выводы про совместные значения `finished`/`started`.

# Пример отсутствия happens-before
```c++
// Thread 1
started = true;
m.lock(); data++; m.unlock();
finished1 = true;
finished2 = true;

// Thread 2
m.lock(); m.unlock();
if (finished2) { // UB
    assert(finished1);  // Непонятно, UB/reordering
    assert(data > 0);   // Непонятно, UB
    assert(started);    // Непонятно, UB
}
```

Если сначала выполнился thread 1, а потом thread 2,
то есть запись `started = true` happened-before чтения `started`, что хорошо.
Но нет никакого happens-before между записью `finished2 = true;` и чтением `finished2`.
То есть при чтении `finished2` будет UB и программа дальше UB.

Более того, ни в одном выполнении happens-before для `finished2` не получится,
то есть это UB вообще всегда.

# Мораль
* Не помогает даже `sleep_for`, он не создаёт никакого happens-before!
  Только маскирует проблемы.
* Мьютексы помогают хорошо: если у нас доступ к данным всегда защищён мьютексом, то в любом выполнении можем найти happens-before в одну из сторон.
* Можно делать хитрые мьютексы (`shared_mutex`): разрешать либо одного "писателя", либо несколько "читателей" одновременно.
  Как в Rust.
* Рекомендация: делайте поменьше общих ресурсов у потоков.
