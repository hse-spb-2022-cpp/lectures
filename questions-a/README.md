# Общее
* В билете написано почти всё, что надо рассказать.
* Для каждой синтаксической конструкции должен быть приведён содержательный пример, когда это требуется или делает код проще/удобнее.
* Вас могут активно спрашивать вокруг билета: если вы сказали, что надо писать `Foo(bar)`, вас могут сразу же спросить, что будет при написании `Foo(&bar)`, вы должны ответить.
* "Не было" — не было на лекции, знать не надо, не спрашивают. Даже если было на практике.

# Обязательные знания
Если вы не знаете какие-то термины что-то из списка ниже, это автоматический неуд.

## Термины
* Свободная функция, функция-член
* Время жизни объекта: автоматическое, динамическое, статическое
* Undefined behavior: что может произойти, примеры:
  * Неинициализированная переменная: почему у неё нет никакого значения, почему не стоит говорить что вместо значения "мусор, который иногда меняется".
  * Выход за границы массива.
  * Dangling reference (висячая ссылка) при возврате из функции, при инвалидации в стандартном контейнере.
  * Разыменование `nullptr`.

## Переменные
* статическая типизация
* тип переменной
* размер переменной, размер типа
* типы <code>int</code>, <code>char</code>: типичные размеры. Например, на архитектуре <code>x86_64</code> под Linux в компиляторе <code>GCC</code>.

## Основные конструкции языков C и C++
* объявления переменных
* выражения и операторы:
  * арифметические (`+`, `-`, `*`, `/`, `%`, `+=`, `-=`, `*=`, `/=`, `%=`, `++`, `--`)
  * булевы (`<`, `<=`, `>`, `>=`, `==`, `!=`, `&&`, `||`, `!`)
  * на минимальную оценку необязательно знать: отличия постфиксных и префиксных операторов
* условный оператор `if`
* циклы `for`, `while`

## Функции
* объявление и определение функции, требуется отличать между собой (можно случайно перепутать, но после вопроса исправиться)
* вызов функции (синтаксис, не нужно знать mangling, конвенции вызовов)
* возвращаемое значение
* рекурсивный вызов

## Основные конструкции C++
* синтаксис `static_cast`
* синтаксис объявления пространств имён, обращения к элементу внутри пространства имён
* `auto` для объявления переменных
* range-based for, в том числе с `auto&` и `const auto&`

## Классы
* определение класса, конструктор, методы
* приватные/защищённые/публичные поля и методы
* наследование: базовый синтаксис, включая вызов конструктора базового класса

## Полиморфные классы
* виртуальные методы и их отличия от невиртуальных
* необходимость виртуального деструктора
* чисто виртуальные функции, что происходит при отсутствии `override` или `virtual`
* хранение полиморфных объектов в контейнерах
* `dynamic_cast` для полиморфных классов (по указателям и ссылкам)

## Const correctness
* синтаксис константных ссылок, применение при передаче аргументов
* невозможность изменять константные объекты и их поля
* const-qualifier у методов (const member function)

## Использование move-семантики
* эффективная инициализация полей класса из аргументов, принятых по значению
* moved-from состояние у объектов: может быть не определено, может быть невозможно обнаружить, пример ошибки
* отсутствие необходимости `move` из результата функции, возвращённого по значению
* необходимость move для явной передачи владения `unique_ptr`

## STL
* использование `vector` как динамического массива фиксированной длины, <code>push_back</code> и <code>emplace_back</code>
* использование `map` со стандартным компаратором, особенность <code>operator[]</code> (создаёт значение даже при чтении)
* `lower_bound`/`upper_bound`: параметры, возвращамое значение

## Си
* использование строк в стиле Си: отличия `char s[10]` и `const char *s`, преобразование в две стороны для `std::string`
* операции со строками в стиле Си: конкатенция, получение длины, безопасная альтернатива для `gets`

## Многопоточность
* базовое использование `thread` (включая `join()`), `mutex` и `unique_lock`
* гонки: пример гонки данных и гонки при выводе на экран, как избежать, умение видеть гонки в произвольном несложном коде

# Билеты
## 1x. Базовый синтаксис и стандартная библиотека
### 10. Базовый синтаксис
* Отличия и примерные границы значений встроенных типов ("на контесте"):
  * `int`, `double` (почему `0.1 + 0.2 != 0.3`), `bool`.
  * `char` как целочисленный тип
  * Знаковость и беззнаковость типов.
* Литералы: целочисленный и вещественный (в том числе `10'000` с C++14), символьный, `LL`.
* Строковые литералы: обычный, raw string literal, экранирование (escaping).
* Склейка подряд написанных строковых литералов на этапе компиляции (`"hello" " world"`).
* `static_cast<>`: пример избавления от переполнения при умножении `int`'ов.
* Разница между `i++` и `++i`.

* Составные операторы присваивания (compound assignment operator) вроде `*=`, `/=`.
* Оператор `,` (запятая) и его отличия от `;`.
* Синтаксис: `for` (включая объявление переменной в `init`), `while`, `if`, где expression и statement.
* Тернарный оператор, отличия от `if`.
* Range-based `for`, в том числе с использованием (константных) ссылок и `auto`, где возникают копирования.
* Порядок вычислений: https://notes.algoprog.ru/cpp/additional.html#id4
  * Внутри выражений: аргументы функции, операнды операторов, возможность interleaving.
  * Short-circuit (ленивые вычисления) логических операторов `&&` и `||`
  * Что изменилось в C++17, почему в `a = b` важно сначала вычислить `b`, потом `a`.

### 11. Объявление объектов внутри одного файла
* Объявление и определение: функции, класса.
* Взаимная рекурсия для: функций, классов, методов внутри одного класса, методов между классами (`A::foo()` возвращает `B` и наоборот).
* Incomplete type: как объявить, что можно сделать с неполным типом.
* Пространства имён: глобальное, вложенное, синтаксис для объявления вложенных namespace с C++11.
* Обращение к вложенному namespace, к глобальному namespace.
* Псевдонимы типов: `typedef`, `using`.
* `using namespace`, где можно и нельзя использовать и почему, особенности `using namespace <другая-библиотека-вроде-std>` (пример с появлением `std::lcm` в C++17 и перегрузкой)

Тесно связано с: линковка.

### 12. Объявление переменных
* Объявление нескольких переменных, указателей, ссылок, в том числе константных.
* Создание временного объекта.
* Отличия copy initialization и direct initialization.
  * Тесно связано с: преобразования (conversions).
* Неинициализированные переменные/поля.
* Инициализация при помощи `{}`:
  * Для тривиальных типов.
  * Для нетривиальных типов.
  * Для массивов/векторов, в том числе вложенных.
  * Временных объектов: с указанием типа (`T{}`, `T()`) и без указания типа (`{}`).
  * Не было: точное определение агрегатных классов.
* Пример, где инициализация через `{}` и `()` компилируются и ведут себя по-разному.
* Ссылки.
  * Можно ли отличить ссылку от объекта, на который она указывает.
  * Использование константных ссылок.
  * Константная ссылка не обещает, что объект не меняется (если ссылка на мутабельный объект).
* `auto` и его модификации со ссылкой, константность, указателем
  * Сохранение лямбды в `auto`

Тесно связно с: параметры функций.

### 13. Подробности именования сущностей
* `[[maybe_unused]]`
* The most vexing parse
  * Когда возникает в обычных переменных, в полях.
  * Как решать, в том числе если нельзя заменить direct initialization (прямая инициализация) на list initialization (инициализация списком)
* Допустимые имена переменных, функций, констант, классов:
  * Нельзя начинать с цифры.
  * Где посмотреть ключевые слова.
  * Где можно и нельзя ставить `_`: https://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier
  * Что происходит от некорректного имени в разных случаях.
* Structured binding для пар, простых структур, массивов, со ссылкой.
  * Проблемы с `std::minmax`
  * Не было: как делать для своих структур, что на самом деле происходит внутри, что происходит с временными значениями.
* Поиск имён
  * Квалифицированный и неквалифицированный поиск, порядок обхода вложенных namespace
  * Отличие между `std::` и `::std::`
  * ADL (argument-dependent lookup) для операторов и функций
* Shadowing переменных в рамках одной функции

### 14. Функции
* Параметры
  * Синтаксис (пропущенное имя, значение по умолчанию в объявлении/определении)
  * Передача параметров по: значению, `&`, `const&`. Что выбрать и почему.
  * Неименованый параметр и `[[maybe_unused]]`
* Возвращаемое значение
  * Возврат по значению, ссылке, константной ссылке.
  * `[[nodiscard]]`, возможные стратегии применения: когда не имеет смысла игнорировать возвращаемое значение
* Перегрузка функций:
  * Что входит в сигнатуру, что не входит (например, значение по умолчанию).
  * Типы-тэги для пояснений к перегрузкам (type tags)
  * Проблемы с разделением `nullptr`, `NULL`, `0`.
  * Не было: `noexcept`.
  * Не было: правил выбора перегрузки точнее "выбирается перегрузка наиболее точная или ambiguous".

Тесно связано с: методы.

### 15. Жизнь объектов
* Семантика копирования: что ожидается в C++ при переприсваивании объекта, передаче в качестве аргумента функции, возврата из функции.
  * А если не `Foo a;`, а `Foo &a = .....;`?
* Время жизни объектов (storage duration): автоматическое (automatic), ручное/динамическое (dynamic), статическое (static).
  * Синтаксис создания/удаления объекта.
  * Когда вызывается конструктор/деструктор и с какими параметрами.
* Время жизни временных объектов.
  * Когда создаётся/уничтожается временный объект ("наивный взгляд" до C++14 включительно, copy elision/RVO/NRVO не было).
  * Продление жизни временого объекта.
  * Проблема продления жизни в `std::min()`/`std::max()`.
  * Проблема продления жизни в range-based-for и цепочке вызовов `foo().bar()`.
* Локальные объекты со static storage duration (локальные статические переменные):
  * Когда создаётся/уничтожается.
  * Чем инициализируются, можно ли инициализировать параметром функции.

### 16. Стандартная библиотека
* Что такое `namespace std`.
* Контейнеры
  * `std::vector`, `std::string`, `std::list`, `std::map`: когда что использовать
  * Основные операции и время работы: `push_back`/`emplace_back`, `front()`/`back()`, `operator[]`, `size()`, `capacity()`, `resize()`, `reserve()`.
  * Особенность `operator[]` у `std::map`: элемент всегда создаётся, даже если его не было, почему.
  * Инвалидация итераторов и ссылок на элементы: когда, какие последствия.
* Итераторы
  * Конвенции с `begin()`/`end()`
  * Когда есть/нет операторов `+=`/`-=`/`+`/`-`
  * Не было: иерархия итераторов, `reverse_iterator`.
* Алгоритмы
  * `sort`, передача своего компаратора.
  * `lower_bound`, `upper_bound`, точные инварианты.
  * `remove_if`, erase-remove idiom, почему неприменим к `std::set`, на что заменить
* Ввод-вывод
  * `cin`/`cout`/`ifstream`/`ofstream`/`istream`/`ostream`/`sstream`
  * Отличия `<iostream>` и `<iosfwd>`
  * Синтаксис ввода и вывода.
  * Перегрузка операторов ввода-вывода для своих классов: конвенции, почему так работает, когда нужны friend-операторы и зачем.
  * Отличия `getline` и `>>` при считывании `std::string`
  * Почему никогда не надо писать `while (!cin.eof())` и как правильно
  * Не было: манипуляторы, свои манипуляторы.

Тесно связано с: функторы, лямбда-функции, базовый синтаксис (порядок вычислений).

### 17. Указатели
* Базовый синтаксис: объявление, разыменование, взятие адреса, `->`.
  * Не было: многоуровневые указатели, константность указателей, aliasing.
* Реализация двусвязного списка, конструкции вроде `a.next->prev`.
* Нулевой указатель.
  * Отличия `nullptr` от `0`
  * Проверка на нулевой указатель.
  * Разменование `nullptr`.
* Отличия указателей от ссылок: изменяемость, обнуляемость, хранение в контейнерах
* Не было: `void*` в любом виде.
* Арифметика указателей, one-past-the-last, array-to-pointer decay
  * Почему указатель нельзя трактовать как просто адрес в памяти
  * Какие указатели можно и нельзя сравнивать на `==`/`!=`, какой результат
  * Какие указатели можно и нельзя сравнивать на `<`/`<=`/`>`/`>=`, какой результат
* C-style-arrays/массивы в стиле Си
  * Инициализация, невозможность копирования, связь с арифметикой указателей
  * Расширение компилятора variable-length-arrays (VLA)
  * Динамическое выделение/освобождение при помощи `new[]`/`delete[]`
* C-style-strings/ASCIIZ-строки/строки в стиле Си
  * Определение
  * Сохранение строкового литерала в `char*`, `char[]`
  * Базовые операции: сравнение, получение длины
  * Выделение памяти/освобождение/конкатенция
  * Небезопасность функций чтения в `char*`, переполнение буфера
  * Кто владеет результатом `c_str()`
  * `const_cast` для совместимости со старым кодом

### 18. `unique_ptr`, управление памятью, move
* Ручное управление памятью: `new`, `delete`, `new[]`, `delete[]`, когда что использовать.
  * Не было: разница между `new int;` и `new int();`
  * Утечка памяти: UB ли, какие последствия, как ловить, как читать вывод sanitizer и Valgrind с примерами.
* Отличия `unique_ptr` от обычного указателя, когда что использовать
* Создание `unique_ptr`: какие есть конструкторы, что делает `make_unique`
  * Проблема с `make_unique` и приватными конструкторами
  * Решения: неработающее с друзьями, работающее с фабричной статической функцией
* Невозможность копирования
* Синтаксис перемещения: в параметры функции, из функции, в/из других переменных (включая поля), в/из контейнеров
  * Когда (не) надо писать `std::move`
* `move` как оптимизация для копируемых объектов, автоматическая поддержка `move` у пользовательских структур
  * moved-from состояние у объектов

Тесно связано с: функции (как передавать параметры), жизнь объектов.

## 2x. Классы
### 20. Классы
* Синтаксис.
* Поля: обычные, константные, ссылки, порядок создание и уничтожения и когда он важен.
* Семантика копирования.
* Конструктор: синтаксис, параметры, когда вызывается.
  * Конструктор по умолчанию: когда генерируется и вызывается
* Инициализация полей: когда что можно и нужно использовать, как они взаимодействуют между собой и с делегирующим конструктором
  * По умолчанию (тривиальных и с конструктором по умолчанию)
  * Default member initializer (C++11)
  * Member initialization list
  * Почему не надо использовать переприсваивание в конструкторе
* Приватные/публичные поля и методы
  * Кто к кому может обращаться, в том числе к другим объектам (а не только `this`)
  * Паттерн: геттеры и сеттеры для поддержания инвариантов, пример с отсутствием/наличием инвариантов
* Отличия `struct`/`class`.
* Вложенные классы.
* Агрегатная инициализация простых классов через `{}`
  * В том числе если члены тоже инициализируются через `{}`.
  * Что если указать не все члены.
  * Не было: строгое определение "простого класса" (агрегата) и его отличия между стандартами C++11, C++14, C++17, C++20.

### 21. Функции-члены (методы)
* Синтаксис объявления и вызова через `.` или `->`.
* Ключевое слово `this`
  * Где его можно не писать, зачем писать хоть где-то.
  * Чем метод отличается от свободной функции.
  * Захват `this` в лямбды: `[]`, `[=]`, `[&]`, `[this]`, `[*this]`.
* Const correctness: ограничение доступа к полям (в том числе ссылочным и указателям) при константном `this`.
  * Когда возникает константный `this`.
  * Const qualifier и ограничения внутри такого метода.
  * Когда будет UB при отбрасывании const qualifier внутри метода.
  * Не было: перегрузка по const qualifier, когда нужна.
* Определение методов внутри и снаружи класса, отсутствие/наличие проблем с множественным определением

### 22. Статические члены класса
* Статические поля:
  * Объявление, определение, когда что необходимо и где.
  * Обращение изнутри класса и снаружи, отличие от глобальных переменных.
  * Доступ к приватным членам в инициализаторе статического поля при определении снаружи класса.
  * Порядок инициализации/удаления.
* Статические методы, отличия от свободных функций и друзей.

Тесно связано с: линковка.

### 23. Друзья и перегрузка операторов
* Друзья-функции.
  * Определение внутри класса, снаружи класса.
  * Объявление до класса, внутри класса.
* Друг из другого namespace
* Виды перегружаемых операторов
  * Унарные, постфиксные/префиксные (как отличить при перегрузке?), бинарные, составное присваивание, сравнение.
  * Не было: перегрузка унарных `operator*` и `operator->`
  * `operator()`.
  * `operator,`, `operator&&` и `operator||` и автоматическое отключение гарантий порядка вычисления аргументов
* Для каждого вида:
  * Что через кого выражать для минимизации лишних копирований и кода.
  * Конвенция для типов параметров, типа возвращаемого значения.
  * Делать оператор свободной функцией или членом, последствия для преобразований (conversions).
* Отличия `a + b`, `a.operator+(b)` (неявные преобразования), `a.operator+()`.
* Не было: `operator<=>`

### 24. Преобразования
* Конструкторы для преобразований и операторы преобразования.
  * Зачем два способа.
  * Что когда выбирается, когда возникают неоднозначности.
* Где вызывается явное преобразование (explicit), а где неявное (implicit).
  * В том числе в `static_cast<>`.
  * В том числе при работе с функциями (параметры, возвращаемое значение) и комбинировании с `{}`. Например, `return {}`.
  * В том числе для `bool`, но не других числовых типов (особенности `operator bool`).
    * Не было: safe bool idiom из C++03.
* Ключевое слово `explicit` для конструкторов и операторов преобразования, зачем нужно для конструкторов с несколькими параметрами или с нулём параметров.

### 25. Функторы и лямбды
* Реализация своих функторов.
  * Перегрузка `operator()`, когда нужен const qualifier.
  * Как использовать с `std::sort`, `std::set`, в том числе функтор без конструктора по умолчанию.
  * Использование указателя на функцию как функтор.
  * Конвенция стандартной библиотеки C++ про отсутствие состояния у функторов, `std::ref`.
* Использование функторов.
  * Сохранение в переменную/аргумент функции/поле класса при помощи `std::function`
  * Не было: шаблоны, сохранение по точному типу
* Лямбда-функции (C++11):
  * Синтаксис и expression для создания, во что превращается лямбда.
  * Возвращаемый тип: неявный вывод.
  * Независимость типов у разных лямбда-функций.
  * Не было: неявное преобразование лямбда-функции без захватов в указатель на функцию.
  * Захваты: отсутствие, по значению, по ссылке, всех по значению, всех по ссылке, `*this` (C++17), с инициализацией (C++14).
  * Ключевое слово `mutable`.

## 3x. Программы из нескольких файлов и сборка
### 31. Программы из нескольких файлов
* Что делает `#include`, в том числе `#include <iostream>` и `#include <iosfwd>`.
* Мотивация.
  * Зачем линковка, когда есть `#include`, отличия
* Единицы трансляции и файлы.
* Как из одного файла заиспользовать глобальный класс/функцию из другого
  * Не было: `extern`-переменные
* Формулировка One Definition Rule, формулировка IFNDR (Ill-Formed, No Diagnostic Required)
  * Пример ошибок линковщика: multiple definition, undefined reference.
  * Что происходит с перегрузками функций
* Типичный заголовочный файл.
  * Конвенция именования заголовочных файлов.
  * Include guards: зачем, как правильно, осторожно с `_`.
  * Опастность неявного включения, концепция include what you use, примеры из стандартной библиотеки вашего компилятора (упражнение `missing-include`).
  * Запрет на реализацию функций.
  * Необходимость подключать заголовочный файл в файл с реализацией.
* Взаимная рекурсия между заголовками и forward header.
  * Incomplete type: как объявить, что можно сделать с неполным типом.
  * Пример forward hearder из стандартной библиотеки (`<iosfwd>`).
* Что обычно (не) пишут в своих заголовочных файлах (в том числе forward); `using namespace std;`.

### 32. One Definition Rule и нарушения IFNDR
* External linkage/internal linkage.
  * Unnamed namespace, где применять
* Формулировка One Definition Rule
  * Что происходит с перегрузками функций
* Пример ошибок линковщика: multiple definition, undefined reference.
* Примеры IFNDR (Ill-Formed, No Diagnostic Required) без ошибок компиляции и линковщика
  * Несовпадение объявлений функций: аргументы по умолчанию, возвращаемое значение.
  * Несовпадение определений классов, что именно должно совпасть по стандарту.
  * Потенциальные проблемы с любыми глобальными переменными (например, `write`).

### 33. Static initialization order fiasco
* Глобальное состояние программы: когда можно избавиться, когда необходимо.
* Создание и уничтожение объектов со статическим временем жизни.
  * У кого статическое время жизни? В том числе у некоторых локальных переменных.
  * Гарантии про порядок создания и уничтожения объектов.
* Пример static initialization order fiasco.
  * Когда существует некорректный порядок инициализации.
  * При использовании стандартной библиотеки, починка через `std::ios_base::Init`
* Решение: идиома construct on first use.
  * Отличия решения с автоматическим временем жизни и с динамическим.

## 4x Наследование и динамический полиморфизм
### 40. Базовое наследование
* Совместимость ссылок и указателей
* Расположение подобъектов в памяти и padding (пустое место для выравнивания)
* Base-cast и derived-cast: неявно и через `static_cast`, когда допускается
  * Потенциальные проблемы при использовании C-style cast вместо `static_cast`
* `public`/`private`/`protected` для методов/полей
  * Не было: private/public наследование

### 41. Использование наследования для неполиморфных классов
* Совместимость ссылок и указателей
* `final` для структур
* Конструкторы и наследование: отличие от наследования обычных методов
  * Вызов родительского конструктора
* Пример неполиморфного наследование при реализации двусвязного списка с фиктивным элементом
* Как вызываются невиртуальные функции при обращении через совместимую ссылку/указатель

### 42. Полиморфные классы
* Полиморфные классы, виртуальные функции, `override`/`final` для методов, отличия от hiding, вызовы виртуальных функций
  * Один из способов реализации: таблица виртуальных функций, в том числе с наследованием
  * Чисто виртуальные функции и абстрактные классы
  * Возможность реализовать и вызвать чисто виртуальную функцию (не в наследнике)
* Виртуальный деструктор: когда, зачем, что будет, если не сделать
* Запрет копирования и перемещения полиморфных объектов: синтаксис
* Вызовы виртуальных функций в конструкторах и деструкторах: обычные, с явным указанием класса через `::`
* `dynamic_cast` для указателей и ссылок (без обработки исключений), проверка `dynamic_cast` внутри `if` одновременно с определением новой переменной, требование на полиморфность класса
* RTTI, оператор `typeid`, типы `type_info` и `type_index`, использование `boost::core::demangle`
* Не было: эмуляция виртуальных операторов (вроде `operator<<`)
* Не было: виртуальные конструкторы и паттерн "фабричная функция" (в том числе для `make_unique` и копирования)

### 45. Использование наследования
* Проблема круга-эллипса (квадрата-прямоугольника) и её решения (ограничение интерфейса на чтение/запись, убирание прямого наследования)
* Создание и использование разделяемой библиотеки через Boost.DLL для системы плагинов на основе полиморфных классов (`11-211124/02-shared-library`)
  * Не было: импорт/экспорт функций (был только импорт глобальных переменных), `LD_PRELOAD`, линковка с динамическими библиотеками, видимость символов и их виды, внутреннее устройство dll/so/dynlib
  * Пример компилирующегося и работающего кода
  * Загрузка и выгрузка разделяемой библиотеки; что при этом происходит с её глобальными переменными

## 5x. Многопоточность
### 51. Базовая многопоточность
* Создание потоков в C++11, передача аргументов в функцию потока по значению и ссылкам
* Гонки: при выводе на экран, по данным, одновременное чтение без записей
* Борьба с гонками: мьютексы, атомарные снимки, RAII-обёртка над мьютексом (`unique_lock`)

### 52. Дизайн многопоточных приложений
* Частичная потокобезопасность `cout`
* Joinable/detached потоки
* Формализм happens-before, неочевидные примеры нарушения и выполнения, возможный reordering

## Явно исключено
* slicing (срезка объектов) при присваивании полиморфного класса в переменную типа "базовый класс", как защититься (хранить только ссылки/умные указатели)

* Expression и statement, что такое тип expression.
* `[[nodiscard]]`: когда игнорировать опасно
* Порядок вычислений
  * При инициализации нескольких переменных.
  * При инициализации при помощи `{}` против `()`.
* отличия `const int*` и `int *const`, рассказывалось только первое
* `auto`: автоматическое добавление `const`
* Hidden friends: определённый внутри класса `friend` без объявления/определения снаружи
* explicit-конструкторы от нескольких параметров, передача `{}` в аргументы функции, `return {.....}`
* Синтаксис `= delete` с C++11.
* Указатели на функции: синтаксис, использование. Конверсии между указателями, что происходит с перегрузками.
* Делегирующие конструкторы
* Проблемы с самоприсваиванием и самомодификацией (как вариант: некорректная реализация `/=` для класса рациональной дроби `Ratio`).
* Допустимые цепочки преобразований: не более одного пользовательского, но числовые можно.
  * Конструктор `std::string` как пользовательское преобразование, где может быть неожиданно
* Слово `inline`
* Ref qualifier `&`,
  * строгие категории значений, ref qualifier `&&`.
* Статические константы: объявления, определение, когда что нужно и где (для тривиальных и нетривиальных типов).
  * Не было: `constexpr`, `char[]`.
* Паттерн: статический метод как конструктор с именем.
* Producer-consumer
* Друзья-классы.
* Разделяемые библиотеки
  * Крайняя желательность совпадения стандартных библиотек C++ и компиляторов при компиляции приложения и плагина
    * Не было: необходимость динамической линковки стандартной библиотеки C++
  * Независимые по умолчанию static storage у приложения и разделяемой библиотеки

* Слово `static` и unnamed namespace
* Использование `inline`-переменных/функций/методов для обхода ODR (`08-211020/03-linkage/01-inline`).
  * Требования к нескольким определениям.
* Отличия `inline` от `static`/unnamed namespace.
* Пример static initialization order fiasco.
  * Когда не существует корректного порядка инициализации.
  * Когда происходит UB (выглядящий как утечка памяти), при этом в программе используется только `std::string`/`std::vector`.

* Точные правила для `protected`: через какие указатели можно обращаться к `protected`-именам родителя/своим/детей; друзья (кроме доступа к protected-полям родителя через друга наследника; тут компиляторы не согласны).
* Hiding, обращение к скрытому имени, `using` для методов и конструкторов (поведение отличается), добавление перегрузок к методу родителя, изменение видимости полей/методов
* Слайсинг и как его избежать

* Deadlock, reentrant-функции, отделение приватного API без блокировок от публичного API с блокировками
* Взаимные блокировки и их избегание при помощи контроля порядка взятия блокировок или `scoped_lock`/`unique_lock`

* иерархия итераторов и их виды
* `::operator new` и их перегрузка
* аллокаторы
* использование виртуального наследования для ABC (abstract base class)
* определения паттернов "Стратегия" и "Фабрика"
* `auto` и `->` в возвращаемом типе функций и лямбд
* value category, строгое определение rvalue, rvalue-ссылки, реализация `std::move`
* конструктор копирования и перемещения, копирующий и перемещающий оператор присваивания, деструктор, правило пяти (кроме виртуальных деструкторов и запрета на копирование/перемещение, они были)
