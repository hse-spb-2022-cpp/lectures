# Обработка ошибок [00:20]
http://joeduffyblog.com/2016/02/07/the-error-model/

John Lakos "Defensive Programming Done Right":
https://www.youtube.com/watch?v=1QhtXRMp3Hg
https://www.youtube.com/watch?v=tz2khnjnUx8

Любая обработка ошибок — это часть алгоритма, контракта и инвариантов программы!
Нет никакого способа добавить обработку ошибок в общем случае, все инструменты языка (те же исключения) — это лишь инструменты.
Если обработка ошибок важна, её тоже надо продумывать и тестировать.
Нельзя просто "сообщить об ошибке в момент возникновения и обработать где удобно"; это так же неточно, как "решить задачу циклами и ифами".

## Два вида ошибок [00:05]
### Ошибки программирования
Любой UB, нарушение инварианта (двоичный поиск, состояние класса), нарушения контракта.

```
void foo(const char *s) {
    printf("%s\n", s);  // Некорректный s.
}
```

* Лучше выявлять на стадии тестирования.
* Обычно видны не сразу, а через какое-то время.
* Можно пробовать проверять и детектировать (например, `vector::at` вместо `vector::operator[]`),
  но не задетектирует всё (потому что баги) и неясно, что делать после обнаружения
  (мало в чём можно быть уверенным).
* Если случилось, то никаких гарантий, all bets are off.
  Баг в программе точно есть, причём неизвестный, могло упасть где угодно.
* На самом деле какие-то гарантии могут быть.
  John Lakos называет нарушения контракта "soft undefined behavior" (мягкое неопределённое поведение): всё ещё можно логически вывести поведение программы.
  Но оно легко приводит к "hard undefined behavior" (жёсткое неопределённое поведение): тут уже вообще ничего сделать нельзя.
  * Я слышал, что двадцать лет назад всё ещё можно было, потому что компиляторы были относительно простые и не эксплуатировали UB для оптимизаций.
  * _Принцип кувалды_: https://thephd.dev/c-undefined-behavior-and-the-sledgehammer-guideline

### Ошибки окружения/предсказуемые ошибки
Некорректный ввод пользователя, файл не найден, оборвалось сетевое соединение...

* Могут произойти независимо от программы.
* Можно предсказать при написании кода.
* Лучше обрабатывать.
* Например, клиент Telegram должен быстро работать, даже если
  сервер внезапно отвалился.
  Переподключиться? Держать ещё одно соединение в запасе? Надо думать.
* Не хватило прав доступа — может, наоборот, не сообщать пользователю,
  зато сообщить администратору.

## Надо думать [00:05]
Бывают пограничные ситуации в разных контекстах.

* На хороших контестах гарантируется, что ввод корректен.
  В сетевых приложениях нас могут хотеть взломать.
* А что если кончился стэк/память/место на диске?
  * Место на диске: можно забить, можно почистить свой собственный кэш.
    Это чаще не обрабатывают почему-то.
  * Память: а если при обработке потребуется ещё память?
  * Не удалась запись в файл: могут быть разные требования к чат-клиенту (который
    может всё скачать с сервера) и самому серверу (которому надо как-то
    восстанавливаться и централизованно сообщать "жёсткий диск сломался").
* Нарушен инвариант структуры — проблема.
  А вот если мы её перед этим считывали по сети, то, может, это попытка взлома
  и надо залогировать и пропустить запрос.
  Мораль: отделяем внешний ввод от внутренних данных программы.

Про каждую ошибку в программе надо думать:

1. Что случится, когда произойдёт? (не "если")
1. Можно ли с ней сделать что-то разумное с точки зрения _пользователя_?
1. Если да, то как эта обработка ошибки встраивается в алгоритм и архитектуру?

## Обработка ошибок [00:05]
Почти всегда можно залогировать ошибку _для разработчика_.

1. Уронить процесс целиком.
   Самое безопасное при ошибках программирования.
   Хотя тоже может нарушить инварианты (например, файл не до конца записали).
   Можно ещё перед этим позвонить домой и отправить багрепорт.
   А потом немедленно упасть, даже если кажется, что всё хорошо.
1. Уронить кусок процесса.
   Только если не ошибка программирования (хотя в Java/Python с изоляцией получше).
   Например, мы сервер и порвалось соединение с клиентом.
1. Как-то обработать: например, попробовать другой адрес для подключения к серверу.
1. Сообщить пользователю и попросить что-нибудь сделать: "файл не найден, выберите другой".
   * Важно понимать, что пользователь далеко не всегда что-то может сделать.
     О каких ошибках и как сообщать пользователю — отдельный вопрос дизайна user experience.

Проще и надёжнее всего уронить программу целиком.

Нет серебрянной пули для обработки ошибок: это такая же часть спецификации
программы, над которой надо хорошо думать заранее и отдельно реализовывать.

## Подавление ошибок [00:05]
Популярная раньше идея (wide contracts):

```
int max(const std::vector<int> &v) {
    if (v.empty()) return -1;
    .....
}
```

Чем плохо:

1. Если что-то пошло не так (вектор пуст), программа продолжает выполнение с _каким-то_ значением. Может быть hard undefined behavior дальше.
2. Ошибки дальше может и не случиться => сложнее найти баг.

Чем хорошо: _иллюзия_ , что всё хорошо.

Даже если включить в контракт, то пользователи его не прочитают и будут не ожидать.

Как обычно делают:

```
int max(const std::vector<int> &v) {
    assert(!v.empty());
    _ASSERT(!v.empty());  // think-cell
    BSLS_ASSERT(!v.empty());  // Bloomberg
    .....
}
```

TODO: расписать подробнее про narrow vs wide (см. запись)
